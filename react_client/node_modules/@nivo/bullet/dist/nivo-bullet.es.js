import { motionDefaultProps, defaultMargin, useMotionConfig, useTheme, getColorScale, useDimensions, Container, SvgWrapper, ResponsiveWrapper } from '@nivo/core';
import { animated, to, useTransition, useSpring } from '@react-spring/web';
import { jsx, jsxs, Fragment } from 'react/jsx-runtime';
import { BasicTooltip, useTooltip } from '@nivo/tooltip';
import { useMemo, createElement } from 'react';
import { Axis } from '@nivo/axes';
import { useInheritedColor } from '@nivo/colors';
import { createLinearScale } from '@nivo/scales';

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}

var BulletMarkersItem = function BulletMarkersItem(_ref) {
  var _ref$animatedProps = _ref.animatedProps,
      color = _ref$animatedProps.color,
      transform = _ref$animatedProps.transform,
      x = _ref$animatedProps.x,
      y1 = _ref$animatedProps.y1,
      y2 = _ref$animatedProps.y2,
      data = _ref.data,
      _onMouseEnter = _ref.onMouseEnter,
      _onMouseMove = _ref.onMouseMove,
      _onMouseLeave = _ref.onMouseLeave,
      _onClick = _ref.onClick;
  return jsx(animated.line, {
    transform: transform,
    x1: x,
    x2: x,
    y1: y1,
    y2: y2,
    fill: "none",
    stroke: color,
    strokeWidth: "5",
    onMouseMove: function onMouseMove(event) {
      return _onMouseMove(data, event);
    },
    onMouseEnter: function onMouseEnter(event) {
      return _onMouseEnter(data, event);
    },
    onMouseLeave: function onMouseLeave(event) {
      return _onMouseLeave(data, event);
    },
    onClick: function onClick(event) {
      return _onClick(data, event);
    }
  });
};

var BulletRectsItem = function BulletRectsItem(_ref) {
  var _ref$animatedProps = _ref.animatedProps,
      x = _ref$animatedProps.x,
      y = _ref$animatedProps.y,
      width = _ref$animatedProps.width,
      height = _ref$animatedProps.height,
      color = _ref$animatedProps.color,
      borderColor = _ref.borderColor,
      borderWidth = _ref.borderWidth,
      data = _ref.data,
      _onMouseEnter = _ref.onMouseEnter,
      _onMouseMove = _ref.onMouseMove,
      _onMouseLeave = _ref.onMouseLeave,
      _onClick = _ref.onClick;
  return jsx(animated.rect, {
    x: x,
    y: y,
    width: to(width, function (value) {
      return Math.max(value, 0);
    }),
    height: to(height, function (value) {
      return Math.max(value, 0);
    }),
    fill: color,
    strokeWidth: borderWidth,
    stroke: borderColor,
    onMouseMove: function onMouseMove(event) {
      return _onMouseMove(data, event);
    },
    onMouseEnter: function onMouseEnter(event) {
      return _onMouseEnter(data, event);
    },
    onMouseLeave: function onMouseLeave(event) {
      return _onMouseLeave(data, event);
    },
    onClick: function onClick(event) {
      return _onClick(data, event);
    }
  });
};

var BulletTooltip = function BulletTooltip(_ref) {
  var color = _ref.color,
      v0 = _ref.v0,
      v1 = _ref.v1;
  return jsx(BasicTooltip, {
    id: v1 ? jsxs("span", {
      children: [jsx("strong", {
        children: v0
      }), " to ", jsx("strong", {
        children: v1
      })]
    }) : jsx("strong", {
      children: v0
    }),
    enableChip: true,
    color: color
  });
};

var defaultProps = {
  layout: 'horizontal',
  reverse: false,
  spacing: 30,
  minValue: 0,
  maxValue: 'auto',
  axisPosition: 'after',
  titlePosition: 'before',
  titleAlign: 'middle',
  titleRotation: 0,
  titleOffsetX: 0,
  titleOffsetY: 0,
  rangeComponent: BulletRectsItem,
  rangeColors: 'seq:cool',
  measureComponent: BulletRectsItem,
  measureColors: 'seq:red_purple',
  markers: [],
  markerComponent: BulletMarkersItem,
  markerColors: 'seq:red_purple',
  rangeBorderWidth: 0,
  rangeBorderColor: {
    from: 'color'
  },
  measureSize: 0.4,
  measureBorderWidth: 0,
  measureBorderColor: {
    from: 'color'
  },
  markerSize: 0.6,
  isInteractive: true,
  tooltip: BulletTooltip,
  animate: motionDefaultProps.animate,
  motionConfig: motionDefaultProps.config,
  margin: defaultMargin,
  role: 'img'
};

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

var stackValues = function stackValues(values, scale, colorScale, type) {
  var useAverage = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

  var _scale$domain = scale.domain(),
      _scale$domain2 = _slicedToArray(_scale$domain, 2),
      min = _scale$domain2[0],
      max = _scale$domain2[1];

  var normalized = [].concat(_toConsumableArray(values), [type === 'measures' || values.includes(max) ? 0 : max]).filter(function (v) {
    return v !== 0;
  }).sort(function (a, b) {
    return a - b;
  });
  return normalized.reduce(function (acc, v1, index) {
    var _last$v;

    var _acc$slice = acc.slice(-1),
        _acc$slice2 = _slicedToArray(_acc$slice, 1),
        last = _acc$slice2[0];

    var v0 = (_last$v = last === null || last === void 0 ? void 0 : last.v1) !== null && _last$v !== void 0 ? _last$v : min;
    var sequentialValue = useAverage === true ? v0 + (v1 - v0) / 2 : v1;
    return [].concat(_toConsumableArray(acc), [{
      index: index,
      v0: v0,
      v1: v1,
      color: colorScale(colorScale.type === 'sequential' ? sequentialValue : index)
    }]);
  }, []);
};
var getComputeRect = function getComputeRect(_ref) {
  var layout = _ref.layout,
      reverse = _ref.reverse,
      scale = _ref.scale,
      height = _ref.height;

  if (layout === 'horizontal') {
    if (reverse === true) {
      return function (d) {
        var x = scale(d.v1);
        var w = scale(d.v0) - x;
        return {
          x: x,
          y: 0,
          width: w,
          height: height
        };
      };
    }

    return function (d) {
      var x = scale(d.v0);
      var w = scale(d.v1) - x;
      return {
        x: x,
        y: 0,
        width: w,
        height: height
      };
    };
  }

  if (reverse === true) {
    return function (d) {
      var y = scale(d.v0);
      var h = scale(d.v1) - y;
      return {
        x: 0,
        y: y,
        width: height,
        height: h
      };
    };
  }

  return function (d) {
    var y = scale(d.v1);
    var h = scale(d.v0) - y;
    return {
      x: 0,
      y: y,
      width: height,
      height: h
    };
  };
};
var computeRects = function computeRects(_ref2) {
  var data = _ref2.data,
      layout = _ref2.layout,
      reverse = _ref2.reverse,
      scale = _ref2.scale,
      height = _ref2.height;
  var computeRect = getComputeRect({
    layout: layout,
    reverse: reverse,
    scale: scale,
    height: height
  });
  return data.map(function (d) {
    return _objectSpread2({
      data: d
    }, computeRect(d));
  });
};

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}

var getPositionGenerator = function getPositionGenerator(_ref) {
  var layout = _ref.layout,
      reverse = _ref.reverse,
      scale = _ref.scale,
      height = _ref.height,
      markerSize = _ref.markerSize;

  if (layout === 'horizontal') {
    return function (marker) {
      var x = scale(marker.value);
      var y = height / 2;
      var rotation = reverse === true ? 180 : 0;
      return {
        x: x,
        y: y,
        size: markerSize,
        rotation: rotation
      };
    };
  }

  return function (marker) {
    var x = height / 2;
    var y = scale(marker.value);
    var rotation = reverse === true ? 270 : 90;
    return {
      x: x,
      y: y,
      size: markerSize,
      rotation: rotation
    };
  };
};

var BulletMarkers = function BulletMarkers(_ref2) {
  var scale = _ref2.scale,
      layout = _ref2.layout,
      reverse = _ref2.reverse,
      markers = _ref2.markers,
      height = _ref2.height,
      markerSize = _ref2.markerSize,
      component = _ref2.component,
      onMouseEnter = _ref2.onMouseEnter,
      onMouseLeave = _ref2.onMouseLeave,
      onClick = _ref2.onClick;
  var getPosition = useMemo(function () {
    return getPositionGenerator({
      layout: layout,
      reverse: reverse,
      scale: scale,
      height: height,
      markerSize: markerSize
    });
  }, [layout, reverse, scale, height, markerSize]);

  var _useMotionConfig = useMotionConfig(),
      animate = _useMotionConfig.animate,
      springConfig = _useMotionConfig.config;

  var transition = useTransition(markers.map(function (marker) {
    return _objectSpread2(_objectSpread2({}, marker), {}, {
      position: getPosition(marker)
    });
  }), {
    keys: function keys(marker) {
      return "".concat(marker.index);
    },
    enter: function enter(_ref3) {
      var color = _ref3.color,
          position = _ref3.position;
      return {
        color: color,
        transform: "rotate(".concat(position.rotation, ", ").concat(position.x, ", ").concat(position.y, ")"),
        x: position.x,
        y1: position.y - position.size / 2,
        y2: position.y + position.size / 2
      };
    },
    update: function update(_ref4) {
      var color = _ref4.color,
          position = _ref4.position;
      return {
        color: color,
        transform: "rotate(".concat(position.rotation, ", ").concat(position.x, ", ").concat(position.y, ")"),
        x: position.x,
        y1: position.y - position.size / 2,
        y2: position.y + position.size / 2
      };
    },
    config: springConfig,
    immediate: !animate
  });
  return jsx(Fragment, {
    children: transition(function (props, _ref5) {
      var position = _ref5.position,
          marker = _objectWithoutProperties(_ref5, ["position"]);

      return createElement(component, _objectSpread2(_objectSpread2(_objectSpread2({
        key: marker.index
      }, marker), position), {}, {
        animatedProps: props,
        data: marker,
        onMouseEnter: onMouseEnter,
        onMouseMove: onMouseEnter,
        onMouseLeave: onMouseLeave,
        onClick: onClick
      }));
    })
  });
};

var BulletRects = function BulletRects(_ref) {
  var animatedProps = _ref.animatedProps,
      data = _ref.data,
      layout = _ref.layout,
      y = _ref.y,
      borderColor = _ref.borderColor,
      borderWidth = _ref.borderWidth,
      component = _ref.component,
      reverse = _ref.reverse,
      scale = _ref.scale,
      height = _ref.height,
      onMouseEnter = _ref.onMouseEnter,
      onMouseLeave = _ref.onMouseLeave,
      onClick = _ref.onClick;
  var rects = useMemo(function () {
    return computeRects({
      data: data,
      layout: layout,
      reverse: reverse,
      scale: scale,
      height: height
    });
  }, [data, layout, reverse, scale, height]);
  var theme = useTheme();
  var getBorderColor = useInheritedColor(borderColor, theme);

  var getTransform = function getTransform(value) {
    return "translate(".concat(layout === 'horizontal' ? 0 : value, ",").concat(layout === 'horizontal' ? value : 0, ")");
  };

  var transform = animatedProps ? to(animatedProps.measuresY, getTransform) : getTransform(y);

  var _useMotionConfig = useMotionConfig(),
      animate = _useMotionConfig.animate,
      springConfig = _useMotionConfig.config;

  var transition = useTransition(rects, {
    keys: function keys(rect) {
      return "".concat(rect.data.index);
    },
    enter: function enter(rect) {
      return {
        x: rect.x,
        y: rect.y,
        width: rect.width,
        height: rect.height,
        color: rect.data.color
      };
    },
    update: function update(rect) {
      return {
        x: rect.x,
        y: rect.y,
        width: rect.width,
        height: rect.height,
        color: rect.data.color
      };
    },
    config: springConfig,
    immediate: !animate
  });
  return jsx(animated.g, {
    transform: transform,
    children: transition(function (props, rect) {
      return createElement(component, {
        key: rect.data.index,
        index: rect.data.index,
        animatedProps: props,
        data: rect.data,
        x: props.x.get(),
        y: props.y.get(),
        borderColor: getBorderColor(rect.data),
        borderWidth: borderWidth,
        width: to(props.width, function (value) {
          return Math.max(value, 0);
        }).get(),
        height: to(props.height, function (value) {
          return Math.max(value, 0);
        }).get(),
        color: props.color.get(),
        onMouseEnter: onMouseEnter,
        onMouseMove: onMouseEnter,
        onMouseLeave: onMouseLeave,
        onClick: onClick
      });
    })
  });
};

var BulletItem = function BulletItem(_ref) {
  var _theme$labels;

  var id = _ref.id,
      scale = _ref.scale,
      layout = _ref.layout,
      reverse = _ref.reverse,
      axisPosition = _ref.axisPosition,
      x = _ref.x,
      y = _ref.y,
      width = _ref.width,
      height = _ref.height,
      _ref$title = _ref.title,
      title = _ref$title === void 0 ? id : _ref$title,
      titlePosition = _ref.titlePosition,
      titleAlign = _ref.titleAlign,
      titleOffsetX = _ref.titleOffsetX,
      titleOffsetY = _ref.titleOffsetY,
      titleRotation = _ref.titleRotation,
      tooltip = _ref.tooltip,
      rangeBorderColor = _ref.rangeBorderColor,
      rangeBorderWidth = _ref.rangeBorderWidth,
      rangeComponent = _ref.rangeComponent,
      rangeColors = _ref.rangeColors,
      ranges = _ref.ranges,
      measureBorderColor = _ref.measureBorderColor,
      measureBorderWidth = _ref.measureBorderWidth,
      measureComponent = _ref.measureComponent,
      measureHeight = _ref.measureHeight,
      measureColors = _ref.measureColors,
      measures = _ref.measures,
      markerComponent = _ref.markerComponent,
      markerColors = _ref.markerColors,
      markerHeight = _ref.markerHeight,
      _ref$markers = _ref.markers,
      markers = _ref$markers === void 0 ? [] : _ref$markers,
      onRangeClick = _ref.onRangeClick,
      onMeasureClick = _ref.onMeasureClick,
      onMarkerClick = _ref.onMarkerClick;
  var theme = useTheme();

  var _useTooltip = useTooltip(),
      showTooltipFromEvent = _useTooltip.showTooltipFromEvent,
      hideTooltip = _useTooltip.hideTooltip;

  var computedRanges = useMemo(function () {
    var rangeColorScale = getColorScale(rangeColors, scale, true);
    return stackValues(ranges, scale, rangeColorScale, 'range');
  }, [rangeColors, ranges, scale]);
  var computedMeasures = useMemo(function () {
    var measureColorScale = getColorScale(measureColors, scale);
    return stackValues(measures, scale, measureColorScale, 'measures');
  }, [measureColors, measures, scale]);
  var computedMarkers = useMemo(function () {
    var markerColorScale = getColorScale(markerColors, scale);
    return markers.map(function (marker, index) {
      return {
        value: marker,
        index: index,
        color: markerColorScale(markerColorScale.type === 'sequential' ? marker : index)
      };
    });
  }, [markerColors, markers, scale]);
  var TooltipComponent = tooltip;

  var rangeNodes = jsx(BulletRects, {
    data: computedRanges,
    scale: scale,
    layout: layout,
    reverse: reverse,
    x: 0,
    y: 0,
    width: width,
    height: height,
    component: rangeComponent,
    borderColor: rangeBorderColor,
    borderWidth: rangeBorderWidth,
    onMouseEnter: function onMouseEnter(range, event) {
      showTooltipFromEvent(jsx(TooltipComponent, {
        color: range.color,
        v0: range.v0,
        v1: range.v1
      }), event);
    },
    onMouseLeave: hideTooltip,
    onClick: function onClick(range, event) {
      onRangeClick === null || onRangeClick === void 0 ? void 0 : onRangeClick(_objectSpread2({
        id: id
      }, range), event);
    }
  });

  var markerNodes = jsx(BulletMarkers, {
    markers: computedMarkers,
    scale: scale,
    layout: layout,
    reverse: reverse,
    height: height,
    markerSize: markerHeight,
    component: markerComponent,
    onMouseEnter: function onMouseEnter(marker, event) {
      showTooltipFromEvent(jsx(TooltipComponent, {
        color: marker.color,
        v0: marker.value
      }), event);
    },
    onMouseLeave: hideTooltip,
    onClick: function onClick(marker, event) {
      onMarkerClick === null || onMarkerClick === void 0 ? void 0 : onMarkerClick(_objectSpread2({
        id: id
      }, marker), event);
    }
  });

  var axisX = layout === 'vertical' && axisPosition === 'after' ? height : 0;
  var axisY = layout === 'horizontal' && axisPosition === 'after' ? height : 0;

  var axis = jsx("g", {
    transform: "translate(".concat(axisX, ",").concat(axisY, ")"),
    children: jsx(Axis, {
      axis: layout === 'horizontal' ? 'x' : 'y',
      length: layout === 'horizontal' ? width : height,
      scale: scale,
      ticksPosition: axisPosition
    })
  });

  var titleX = layout === 'horizontal' ? titlePosition === 'before' ? titleOffsetX : width + titleOffsetX : height / 2 + titleOffsetX;
  var titleY = layout === 'horizontal' ? height / 2 + titleOffsetY : titlePosition === 'before' ? titleOffsetY : width + titleOffsetY;

  var titleNode = jsx("g", {
    transform: "translate(".concat(titleX, ",").concat(titleY, ") rotate(").concat(titleRotation, ")"),
    children: typeof title === 'string' ? jsx("text", {
      style: _objectSpread2(_objectSpread2({}, theme === null || theme === void 0 ? void 0 : (_theme$labels = theme.labels) === null || _theme$labels === void 0 ? void 0 : _theme$labels.text), {}, {
        dominantBaseline: 'central',
        textAnchor: titleAlign
      }),
      children: title
    }) : title
  });

  var _useMotionConfig = useMotionConfig(),
      animate = _useMotionConfig.animate,
      springConfig = _useMotionConfig.config;

  var animatedProps = useSpring({
    measuresY: (height - measureHeight) / 2,
    transform: "translate(".concat(x, ",").concat(y, ")"),
    config: springConfig,
    immediate: !animate
  });
  return jsxs(animated.g, {
    transform: animatedProps.transform,
    children: [rangeNodes, jsx(BulletRects, {
      animatedProps: animatedProps,
      data: computedMeasures,
      scale: scale,
      layout: layout,
      reverse: reverse,
      x: 0,
      y: 0,
      width: width,
      height: measureHeight,
      component: measureComponent,
      borderColor: measureBorderColor,
      borderWidth: measureBorderWidth,
      onMouseEnter: function onMouseEnter(measure, event) {
        showTooltipFromEvent(jsx(TooltipComponent, {
          color: measure.color,
          v0: measure.v1
        }), event);
      },
      onMouseLeave: hideTooltip,
      onClick: function onClick(measure, event) {
        onMeasureClick === null || onMeasureClick === void 0 ? void 0 : onMeasureClick(_objectSpread2({
          id: id
        }, measure), event);
      }
    }), axis, markerNodes, titleNode]
  });
};

var useEnhancedData = function useEnhancedData(data, _ref) {
  var layout = _ref.layout,
      maxValue = _ref.maxValue,
      minValue = _ref.minValue,
      reverse = _ref.reverse,
      height = _ref.height,
      width = _ref.width;
  return useMemo(function () {
    return data.map(function (d) {
      var _d$markers;

      var all = [].concat(_toConsumableArray(d.ranges), _toConsumableArray(d.measures), _toConsumableArray((_d$markers = d.markers) !== null && _d$markers !== void 0 ? _d$markers : []));
      var max = maxValue !== null && maxValue !== void 0 ? maxValue : Math.max.apply(Math, _toConsumableArray(all));
      var min = minValue !== null && minValue !== void 0 ? minValue : Math.min.apply(Math, _toConsumableArray(all));
      var scale = createLinearScale({
        clamp: true,
        min: min,
        max: max,
        type: 'linear'
      }, {
        all: all,
        max: max,
        min: min
      }, layout === 'horizontal' ? width : height, layout === 'horizontal' ? reverse ? 'y' : 'x' : reverse ? 'x' : 'y');
      return _objectSpread2(_objectSpread2({}, d), {}, {
        scale: scale
      });
    });
  }, [data, height, layout, maxValue, minValue, reverse, width]);
};

var Bullet = function Bullet(props) {
  var _defaultProps$props = _objectSpread2(_objectSpread2({}, defaultProps), props),
      data = _defaultProps$props.data,
      layout = _defaultProps$props.layout,
      spacing = _defaultProps$props.spacing,
      measureSize = _defaultProps$props.measureSize,
      markerSize = _defaultProps$props.markerSize,
      reverse = _defaultProps$props.reverse,
      axisPosition = _defaultProps$props.axisPosition,
      minValue = _defaultProps$props.minValue,
      maxValue = _defaultProps$props.maxValue,
      partialMargin = _defaultProps$props.margin,
      width = _defaultProps$props.width,
      height = _defaultProps$props.height,
      titlePosition = _defaultProps$props.titlePosition,
      titleAlign = _defaultProps$props.titleAlign,
      titleOffsetX = _defaultProps$props.titleOffsetX,
      titleOffsetY = _defaultProps$props.titleOffsetY,
      titleRotation = _defaultProps$props.titleRotation,
      rangeBorderColor = _defaultProps$props.rangeBorderColor,
      rangeBorderWidth = _defaultProps$props.rangeBorderWidth,
      rangeComponent = _defaultProps$props.rangeComponent,
      rangeColors = _defaultProps$props.rangeColors,
      measureBorderColor = _defaultProps$props.measureBorderColor,
      measureBorderWidth = _defaultProps$props.measureBorderWidth,
      measureComponent = _defaultProps$props.measureComponent,
      measureColors = _defaultProps$props.measureColors,
      markerComponent = _defaultProps$props.markerComponent,
      markerColors = _defaultProps$props.markerColors,
      theme = _defaultProps$props.theme,
      _defaultProps$props$t = _defaultProps$props.tooltip,
      tooltip = _defaultProps$props$t === void 0 ? defaultProps.tooltip : _defaultProps$props$t,
      animate = _defaultProps$props.animate,
      motionConfig = _defaultProps$props.motionConfig,
      isInteractive = _defaultProps$props.isInteractive,
      onRangeClick = _defaultProps$props.onRangeClick,
      onMeasureClick = _defaultProps$props.onMeasureClick,
      onMarkerClick = _defaultProps$props.onMarkerClick,
      role = _defaultProps$props.role;

  var _useDimensions = useDimensions(width, height, partialMargin),
      margin = _useDimensions.margin,
      innerWidth = _useDimensions.innerWidth,
      innerHeight = _useDimensions.innerHeight;

  var itemHeight = layout === 'horizontal' ? (innerHeight - spacing * (data.length - 1)) / data.length : (innerWidth - spacing * (data.length - 1)) / data.length;
  var measureHeight = itemHeight * measureSize;
  var markerHeight = itemHeight * markerSize;
  var enhancedData = useEnhancedData(data, {
    height: innerHeight,
    layout: layout,
    maxValue: maxValue === 'auto' ? undefined : maxValue,
    minValue: minValue === 'auto' ? undefined : minValue,
    reverse: reverse,
    width: innerWidth
  });
  return jsx(Container, {
    isInteractive: isInteractive,
    theme: theme,
    animate: animate,
    motionConfig: motionConfig,
    children: jsx(SvgWrapper, {
      width: width,
      height: height,
      margin: margin,
      role: role,
      children: enhancedData.map(function (d, i) {
        return jsx(BulletItem, _objectSpread2(_objectSpread2({}, d), {}, {
          layout: layout,
          reverse: reverse,
          x: layout === 'vertical' ? itemHeight * i + spacing * i : 0,
          y: layout === 'horizontal' ? itemHeight * i + spacing * i : 0,
          width: innerWidth,
          height: itemHeight,
          titlePosition: titlePosition,
          titleAlign: titleAlign,
          titleOffsetX: titleOffsetX,
          titleOffsetY: titleOffsetY,
          titleRotation: titleRotation,
          measureHeight: measureHeight,
          markerHeight: markerHeight,
          rangeBorderColor: rangeBorderColor,
          rangeBorderWidth: rangeBorderWidth,
          rangeComponent: rangeComponent,
          rangeColors: rangeColors,
          measureBorderColor: measureBorderColor,
          measureBorderWidth: measureBorderWidth,
          measureComponent: measureComponent,
          measureColors: measureColors,
          markerComponent: markerComponent,
          markerColors: markerColors,
          axisPosition: axisPosition,
          onRangeClick: onRangeClick,
          onMeasureClick: onMeasureClick,
          onMarkerClick: onMarkerClick,
          tooltip: tooltip
        }), d.id);
      })
    })
  });
};

var ResponsiveBullet = function ResponsiveBullet(props) {
  return jsx(ResponsiveWrapper, {
    children: function children(_ref) {
      var width = _ref.width,
          height = _ref.height;
      return jsx(Bullet, _objectSpread2({
        width: width,
        height: height
      }, props));
    }
  });
};

export { Bullet, BulletItem, ResponsiveBullet, defaultProps };
//# sourceMappingURL=nivo-bullet.es.js.map
